## 파싱 종류
### 소프트 파싱 이란
- SQL과 실행계획을 캐시에서 찾아 곧바로 실행단계로 넘어가는 경우
### 하드 파싱
- SQL과 실행계획을 캐시에서 찾지 못해 최적화 과정을 거치고 나서 실행단계를 넘어가는 경우
- ":custno"라는 변수로 사용하여 Where절에 쓰일 때, 이는 SQL 커서로 공유와 재사용이 가능하기 때문에 한번만 하드파싱되고 계속 사용된다.
- 캐시에서 SQL과 실행계획을 식별하는 식별자는 SQL 문자 그 자체로, 옵티마이저는 문자 하나만 달라도 서로 다른 SQL로 인식해 각각 하드파싱을 일으키고 다른 캐시 공간을 사용한다.
- 하드파싱이 각각 발생해도 SQL이 의미상 동일하다면 실행계획은 동일하다.

## 바인드 변수 
- 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데
- SQL과 실행계획을 여러 개 캐싱하지 않고 하나를 반복 재사용하므로 파싱 소요기간과 메모리 사용량을 줄여주는 변수
- 사용자의 입력 조건이 다양해서 조건절을 동적으로 구성하더라도 조건절 비교 값만큼은 바인드 변수를 사용하려고 노력해야한다.

## Literal 상수 조건이 바인드 변수 보다 효율적인 경우
- 수행빈도가 낮고 한 번 수행할 떄 수십 초 이상 수행되는 SQL
- 조건절 컬럼의 값 종류가 소수이고, 값 분포가 균일하지 않을 때
- 사용자가 입력할 수 있는 조회 항목이 아니어서 해당 조건절이 불변일 때

## 다음 프로그램의 설명
![image](https://github.com/user-attachments/assets/3f865571-2501-4beb-99d1-2119257720a5)
- 바인드 변수를 사용했으므로 불필요한 하드파싱은 줄어든다
- 함수 내 선언된 SQL은 NDS(Native Dynamic SQL)로 호출 시 권한 및 문법 체크를 하므로 테이블의 DDL 에 영향을 받지 않는다.
- 바인드 변수를 사용했으므로 칼럼 히스토그램은 활용하지 못하지만, 레코드 건수, 칼럼 값의 종류, Null 값 개수 등을 활용해 실행계획을 수립한다.
- 테이블과 함수가 서로 종속적이지 않다.
- 인덱스 전략 수립이 어렵다

## SQL 작성 방식
- Static SQL이란, String 형 변수에 담지 않고 코드 사이에 직접 기술한 SQL문
- Dynamic SQL이란, String형 변수에 담아서 실행하는 SQL 문
- Static SQL을 지원하는 개발환경에서는 가급적 Static SQL로 작성하는 것이 바람직하다.
- 루프 내에서 반복 수행되는 SQL이라도 바인드 변수를 사용하기만 하면 캐싱된 SQL을 공유할 수 있다.
- Static SQL은 PreCompile 과정을 거치므로 런타임 시 안정적인 프로그램 Build가 가능하다.
- Dynamic SQL 사용 시 애플리케이션이 큰 경우 캐싱이 작동하지 않을 수 있다.

## 비용기반 옵티마이저의 쿼리 최적화 과정에서의 비용
- 비용이란 기본적으로 SQL 수행 과정에 수반될 것으로 옜아되는 I/O의 양
- 옵티마이저가 비용을 계산할 때, CPU 속도, 디스크 I/O 속도 등도 고려
- 최신 옵티마이저는 I/O에 CPU 연산 비용을 더해서 비용 계산
- (데이터베이스 Call은 옵티마이저 수립한 실행계획에 따라 SQL을 수행하는 과정에, 또는 옵티마이저에게 실행계획을 수립해 달라고 요청하는 과정에 발생)
### CBO를 사용하는 경우
- 직급의 종류 개수(NDV, Number Of Distinct Value)는 CBO의 가장 대표적인 통계정보

## 규칙기반 옵티마이저(= 휴리스틱 옵티마이저)
- 미리 정해 놓은 규칙에 따라 액세스 경로를 평가하고 실행계획을 선택
- 규칙 = 액세스 경로별 우선순위로 인덱스 구조, 연산자, 조건절 형태가 순위를 결정짓는 주요인이다.
### RBO를 사용하는 경우
- 인덱스가 있는 경우
- 인덱스가 있어 order by 소트 연산 대체
-  between 또는 scan 범위에 대해서 인덱스 사용

## 옵티마이저 모드
### ALL_ROWS(전체범위 최적화)
- 전체 처리속도 최적화
- 전체를 읽는 것을 전제로 시스템 리소스를 가장 적게 사용하는 실행계획 선택
- 즉, 전체 처리 속도 최적화가 목표
- 부분범위 최적화와 비교할 떄, Index Scan보다 Table Full Scan 하는 실행계획을 더 많이 생성
- DML 문장은 옵티마이저 모드와 상관없이 항상 전체범위 최적화 방식으로 최적화된다.
### FIRST_ROWS(부분범위 최적화ㄴ)
- 최초 응답속도 최적화
- 앞쪽 일부분만 읽다가 멈추는 것을 전제로 응답 속도가 가장 빠른 실행계획을 선택
- 즉, 최초 응답속도 최적화가 목표
- ALL_ROWS와 비교에서, Table Full Scan 보다는 인덱스를 더 만힝 선택하고, 해시 조인/소트머지조인 보다 NL 조인을 더 많이 선택
### FIRST_ROWS_N
- 최초 N건 응답속도 최적화
- 앞쪽 N개 로우만 읽고 멈추는 것으 전제로 응답속도가 가장 빠른 실행계획을 선택

## 통계정보 수집 시 고려사항
- 시간/주기: 부하가 없는 시간 내 가능한 빨리 수집
- 표본 크기: 가능한 한 적은 양의 데이터를 읽고도 전수 검사할 떄의 통게치에 근접하도록 해야 한다.
- 정확성: 표본 검사하더라도 전수 검사할 때의 통계치에 근접해야 함
- 안정성: 데이터에 큰 변화가 있어도 매번 통계치가 바뀌지 않아야 함

## 뷰 병합
- 뷰를 사용하는 쿼리 최적화 과정 중 하나
- 뷰 병합 케이스: 뷰간의 병합, 뷰와 기본테이블의 병합
- 뷰를 사용하는 쿼리는 크게 뷰쿼리와 액세스 쿼리로 나누어진다.
    - 뷰쿼리: SELECT문 그 자체
    - 액세스 쿼리: 이 뷰를 수행하는 SQL
- 뷰 머징 쿼리변환이 발생하지 않도록 제어하는 옵티마이저 힌트 = NO_MERGE
    - NO_PUSH_PRED: 조인조건 PUshdown을 방지
    - NO_UNNEST: 서브쿼리를 필터 방식으로 최적화
    - NO_REWIRTE: 구체화 뷰의 쿼리 재작성 기능을 방지
### 뷰 병합이 불가능한 조건
- 집합 연산
- CONNECTED BY
- ROWNUM을 사용한 경우
- SELECT-LIST의 집계함수(AVG, COUNT, MAX, MIN, SUM) (GROUPBY 없이 전체를 집계하는 경우)
- 분석 함수 사용

