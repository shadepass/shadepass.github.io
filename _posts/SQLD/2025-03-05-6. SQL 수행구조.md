## 실행계획에 대한 설명
### 실행 계획을 통해 알 수 있는 정보
- 액세스 기법
- 질의 처리 예상 비용
- 조인 순서
- (실제 처리 건수는 **트레이스** 정보로 확인 가능)
### 실행계획에 대한 설명
- 실행계획은 SQL 처리를 위한 실행 절차와 방법을 표현한 것
- 실행계획은 조인 방법, 조인 순서, 액세스 기법 등 표현
- 실행계획이 변경되면 SQL 출력 순서도 변경
- CBO(Cost Based Optimizer)의 실행계획에는 단계별 예상 비용 및 건수 등이 표신된다.
- 오라클의 규칙 기반 옵티마이저에서 가장 우선 순위가 높은 규칙은 Single row by rowid 액세스 기법이다.
- 비용기반 옵티머아저는 테이블, 인덱스, 컬럼 등 객체의 통계정보를 사용하여 실행계획을 수립하므로 통계정보가 변경되면 SQL의 실행 계획이 달라질 수 있다.
- 오라클의 실행계획에 나타나는 기본적인 Join 기법으로는 NL Join, Hahs JOin, Sort Merge Join 등이 있다.
- NL Join은 OLTP의 목록 처리 업무에 많이 사용된다.
- DW 등의 데이터 집계 업무에서 많이 사용되는 Join 기법은 Hash Join 또는 Sort Merge Join 이다.

## 오라클에서의 I/O 단위: 블록(Block)

## 버퍼 설명
1. 더티 버퍼
버퍼에 캐시된 이후 변경이 발생했지만, 아직 디스크에 기록되지 않아 데이터 파일 블록과 동기화가 필요한 상태의 버퍼 블록
2. 프리버퍼
더티 버퍼를 재사용하기 위해 디스크에 기록하는 순간 변경되는 버퍼
3. 리사이클, 킵은 멀티 버퍼 풀을 구성하는 영역 중 하나

## I/O 효율화 원리
- 동일한 데이터를 중복 액세스하지 않도록 해야 한다.
- 옵티마이저에 정확한 통계정보를 제공한다.
- 옵티마이저 힌트를 사용해 최적의 액세스 경로를 유도한다.

## 데이터베이스 관련
### 데이터베이스 연결 관련
- 연결 요청에 대한 부하는 스레드 기반 아키텍처 보다 프로세스 기반 아키텍처에서 더 심하게 발생한다.
- 전용 서버 방식으로 오라클 데이터베이스에 접속하면 사용자가 데이터베이스 서버에 연결 요청을 할 때마다 서버 프로세스가 생성된다.
- 공유 서버 방식으로 오라클 데이터베이스에 접속하면 사용자 프로세스는 서버 프로세스와 직접 통신하지 않고 Dispatcher 프로세스를 거친다.
- 다중 사용자 환경에서 서버와 모든 클라이언트 간 연결상태를 지속하면 서버 자원을 낭비하게 되지만 매번 연결 요청을 반복하면 성능에 좋지 않다. 따라서, OLTP 성 애플리케이션에선 Connection Pooling 기법 활용이 필수적이다.
### 데이터베이스 저장 구조
- 데이터를 읽고 쓰는 범위는 블록(페이지)
- 데이터 파일에 공간을 할당하는 단위는 익스텐트
- 익스턴트 내 블록들은 서로 인접하지만, 익스텐트끼리 서로 인접하지는 않다.
- SQL Server에서는 한 익스텐트에 속한 페이지들을 여러 오브젝트가 나누어 사용할 수 있다.
### 데이터베이스 I/O
- 데이터 블록을 스캔할 때는 Random I/O 방식을, 인덱스 블록을 스캔할 때는 Sequencial I/O 방식 사용
- Multiblock I/O란 한 Extent에 속한 블록을 가져오는 것
- Singleblock I/O와 Multiblock I/O는 테이블 크기와는 상관 없다.
- I/O는 항상 Block 단위로 수행한다.
- Single Block I/O는 한 번의 I/O Call에 하나의 데이터 블록만 읽어 메모리에 적재하는 방식
- Multiblock I/O는 I/O Call이 필요한 시점에 인접한 블록들을 같이 읽어 메모리에 적재하는 방식
- I/O 튜닝의 핵심은 Sequential 액세스에 의한 선택 비중을 높이고, Random 액세스 발생량을 줄이는 것 
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 Rnadom I/O를 이용하고 풀 테이블 스캔은 Sequential 액세스를 사용한다.
- Direct Path I/O는 병렬로 Full Scan 할 때 주로 발생한다.
- Single Block은 인덱스를 통해 액세스할 때, Multiblock I/O는 인덱스를 이용하지 않고 테이블 전체를 스캔할 때
- 한 쿼리 내에서 같은 블록을 반복하여 액세스하면 버퍼 캐시 히트률은 높아진다.
- 테이블을 Full Scna할 때, 테이블이 작은 extent로 구성되어 있을 수록 더 많은 I/O Call 발생(extent를 범위 넘어서까지 읽어 올 수 없어, 쪼개진 Extent를 더 많이 호출해야함)
- 인덱스를 통한 테이블 액세스 시에는 Extent 크기가 I/O Call 횟수에 영향을 미치지 않음
- 단 하나의 레코드를 읽더라도 해당 레코드가 속한 블록을 통째로 읽는다.
- Sequential I/O 방식은 테이블이나 인덱스를 스캔할 때 사용되며, Random I/O 방식은 인덱스 스캐하면서 테이블을 액세스할 떄 사용
- MPP(Massively Parallel Processing) 방식의 데이터베이스의 제품에선 각 프로세스가 독립적인 메모리 공간을 사용하며, 데이터를 저장할 때도 각각의 디스크를 사용한다. 읽을 떄도 동시에 각각의 디스크를 액세스하기 때문에 병렬 I/O 효과가 극대화된다.

## Redo 로그(또는 트랜잭션 로그) 매커니즘
- 버퍼 캐시 블록을 갱신하기 전에 변경 사항을 먼저 로그 버퍼에 기록해야하며, Dirty 버퍼를 디스크에 기록하기 전에 해당 로그 엔트리를 먼저 로그 파일에 기록해야 한다는 특징은 **"Write Ahead Logging"** 특징
- Fast Commit: 사용자의 갱신 내용이 메모리상의 버퍼 블록에만 기록된 채 아직 디스크에 기록되지 않았지만 Redo 로그를 믿고 빠르게 커밋을 완료하는 것
- Delayed Block Cleanout: 오라클만의 독특한 매커니즘으로서, 변경된 블록을 커밋 시점에 바로 Cleanout(로우 Lock 정보 해제, 커밋 정보 기록)하지 않고 그대로 두었다가 나중에 해당 블록을 처음 읽는 세션에 의해 정리되도록 하는 것

## 메모리 구조
- DB 버퍼 캐시는 데이터파일로부터 읽어 들인 데이터 블록을 담는 캐시 영역
- /*+ append */ 힌트를 사용하면 Insert 시 DB 버퍼 캐시를 거치지 않고 디스크에 직접 쓴다.
- 클러스터링 팩터가 좋은 인덱스를 사용하면 Buffer Pinning 효과로 I/O를 줄일 수 있다.
- Table Full Scan을 한 경우 데이터 블록은 LRU(Least Recently Used) end에 위치하므로 버퍼 캐시에 오래 머물지 않는다.

## I/O 튜닝의 핵심 원리는 
Sequential 액세스에 의한 선택 비중을 높이고 Random 액세스 발생량을 줄이는 것

## 버퍼 캐시 히트율
버퍼 캐시 효율을 측정하는 지표로, 전체 읽은 블록중에서 메모리 버퍼 캐시에서 찾은 비율을 나타낸다.
- 즉 물리적인 디스크 읽기 없이 바로 메모리에서 블록을 찾은 비율
- 총 읽은 블록 수 = query + current
- 디스크에서 읽은 수 = disk

## 오라클 DB의 AWR Report 일부분
![image](https://github.com/user-attachments/assets/f4761ada-fc0b-4cfc-bd22-3172ecc5d414)
- 현재보다 Full Scan으로 더 많이 유도해야한다.
- 기존보다 더 효율적인 인덱스 생성 및 사용으로 어느 정도 sequential read 부하를 줄일 수는 있겠지만 가장 적절한 방식은 아니다.
- 배치쿼리는 FULL SCAN + HASH Join 방식으로 유도하는게 좋다.

## SQL 성능비교
![image](https://github.com/user-attachments/assets/04dd07e0-ef0e-4b7e-b724-9d24053724e1)
- [가입일자 + 고객명]을 선두로 갖는 인덱스를 사용한다면 (가)는 인덱스만 읽고 처리 할 수 있기때문에 (나) 보다 블록 I/O가 더 적게 발생한다.
- (나)가 모든 칼럼을 클라이언트에게 전송해야 하므로 네트워크 트래픽이 더 많이 발생
- 소트 공간은 전송하고자 하는 컬럼을 저장하기 때문에 (나)가 많은 소트 공간을 차지한다.
- 가입일자만으로 구성된 단일 컬럼 인덱스를 사용한다면 두 SQL 모두 테이블 엑세스가 불가피하므로 블록 I/O는 동일하다.