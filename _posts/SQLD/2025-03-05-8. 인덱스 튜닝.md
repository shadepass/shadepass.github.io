## PK 순서 결정 
- 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다.
- 앞쪽에 위치한 속성은 "="아니면 최소 범위인 between, <> 이 와야한다.

## 어떤 데이터 모델에서 학생들이 본인이 수강하고 있는 개설과정에 대한 정보를 검색하는 경우가 매우 빈번하다고 할 때, 성능을 고려한 개선 방법
- 임의의 학번을 검색조건으로 사용하는 경우가 빈번할 것이므로 학번을 속성 선두로 하는 경우 인덱스 사용 효율이 가장 좋을 것이다.

## 데이터모델에 표현된 FK(Foreign Key)에 대한 설명
- 엔터티 간에 논리적 관계가 있을 경우, 데이터베이스 상에서 DBMS가 제공하는 FK Contstraints를 생성했는지 여부와 상관없이 조인 성능을 향상하기 위한 인덱스를 생성해주는 것이 좋다.

## 인덱스에 대한 설명
- 인덱스는 검색 성능 최적화에 사용된다.
- 인덱스가 많으면 INSERT, UPDATE, DELETE와 같은 DML 작업 시 오히려 성능이 느려질 수있다.
- 인덱스는 구성하는 칼럼의 데이터와 레코드 식별자(ROWID)로 구성되어 있따.
- 인덱스는 BETWEEN, > 와 같은 범위검색에도 사용 가능
- DBMS에서 가장 일반적인 인덱스는 B-Tree 구조이다.
- 루트, 브랜치, 리프 블록으로 구성된다.
- 인덱스 검색이 테이블 스캔보다 비효율적일 수 있다.
- 리프 블록은 가장 아래 단계로 레코드 식별자를 가지고 있다.
- 인덱스를 생성할 때 오름차순, 내림차순 선택 가능
- 비용기반 옵티마이저는 SQL을 수행하는데 드는 비용을 계산하여 실행계획을 생성하므로 인덱스가 존대하더라도 전체 테이블 스캔이 유리하다고 판단할 수도 있다.
- 인덱스 범위 스캔은 결과 건수만큼 반환하지만, 결과가 없으면 한 건도 반환하지 않을 수 있다.
- 규칙 기반 옵티마이저는 적절한 인덱스가 존재하면 항상 인덱스를 사용하려고 한다.
- 범위 조건의 경우 범위가 넓을 수록 인덱스 검색효율이 저하된다.
- B-Tree index는 일반적으로 테이블 내의 데이터 중 10% 이하의 데이터를 검색할 때 유리하다.
- SQL Server의 클러스터형 인덱스는 오라클의 IOT와 매우 유사하다.
- 인덱스는 INSERT와 DELETE와 다르게 UPDATE 작업에서는 부하가 없을 수도 있다.
- index range scan이 가능하려면 인덱스 선두 칼럼이 조건절에 사용되어야 한다.(NULL 같은 값이든 상관없음)
- 인덱스랑 동일하지 않은 자료형으로 스캔 시 인덱스 활용이 불가능하다.(문자형 함수를 숫자형으로 비교 시 자동으로 재가공이 수행해야 하기 때문에)
- 다중 IN 절의 경우 가공으로 보지 않음
- 한 테이블의 건수가 매우 많은 경우 테이블 조인 순서에 따른 효과는 미비하다.
### 인덱스 종류
- B-TREE 인덱스  
브랜치 블록과 리프 블록으로 굿어되며, 브랜치 블록은 분기를 목적으로 하고 리프블록은 인덱스를 구성하는 칼럼의 값으로 정렬된다. 일반적으로 OLTP 시스템 환경에서 가장 많이 사용됨
> B-Tree 인덱스의 수직적 탐색은 동일한 깊이를 보장한다
- CLUSTERED 인덱스  
인덱스의 리프 페이지가 곧 데이터 페이지이며, 리프 페이지의 모든 데이터는 인덱스 키 칼럼 순으로 물리적으로 정렬되어 저장된다.
- BITMAP 인덱스  
시스템에서 사용될 질의를 시스템 구현 시에 모두 알 수 없는 경우인 DW 및 AD-HOC 질의 환경을 위해서 설계되었으며, 하나의 인덱스 키 엔트리가 많은 행에 대한 포인터를 저장하고 있는 구조이다.
> Lock에 의한 DML 부하가 심한 것이 단점  
> 레코드 하나만 변경되더라도 해당 비트맴 범위에 속한 모든 레코드에 Lock 걸림
### 인덱스 탐색 과정(수직적/수평적 탐색)
- 수평적 탐색: 인덱스 리프 블록에 저장된 레코드끼리 연결된 순서에 따라 좌/우 또는 우/좌로 스캔하는 것
- 수직적 탐색: 수평적 탐색을 위한 시작 지점을 찾는 과정
> 수평적 탐색 시작 지점은 딱 조건이 맞기 시작한 지점부터라고 이해하면된다.  
> 만약 Less than or equal인 경우에는 시작지점이 없는데, more than or equal이면 시작지점이 있다.
### 인덱스 스캔 종류
1. Index Skip Scan: 루트 또는 브랜치 블록에서 읽은 칼럼 값 정보를 이용해 조건에 부합하는 레코드를 포함할 "가능성이 있는" 하위 블록만 골라서 액세스하는 방식
2. Index Full Scan: 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식, 최적의 인덱스가 없을 때 차선으로 선택됨
> 선두 칼럼을 가공하거나 누락한 경우에 사용할 수 있다. 
3. Index Unique Scan은 수직적 탐색만으로 데이터를 찾는 방식으로서 "="조건으로 탐색하는 경우에 작동
> 단일, 결합 칼럼으로 생성된 Unique Index의 칼럼 대상
4. Index Fast Full Scan: 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock Read 방식으로 스캔하기 때문에 Full Scan 보다 빠름
> 인덱스 칼럼대로 결과의 정렬을 보장하지 않는다.
5. Index Range Scan: 인덱스 루프 블록에서 리프 블록까지 수직적으로 탐색 한 후에 리프 블록을 필요한 범위만 스캔하는 방식
### 인덱스 설계를 위한 고려사항
- 쿼리 수행 빈도
- 업무상 중요도
- 클러스터링 팩터
- 데이터 양
- DML 부하
- 저장 공간
- 인덱스 관리 비용 등
### 결합 인덱스 구성
- 첫 번째 기준은 조건절에 항상 사용되거나 적어도 자주 사용되는 컬럼 선정
- 두 번째 기준은 "=" 조건으로 자주 조회되는 칼럼을 앞쪽에
- 세 번째 기준은 소트오퍼레이션을 생략하도록 하기 위해 칼럼을 추가

## SQL 튜닝
- WHERE 문의 인덱스 이외의 조건에 대해서 필터링은 테이블 액세스 단계에서 이루어진다.
- 조건절에 인덱스만 있다고 해도 출력문에 이외의 컬럼이 있다면 테이블에 액세스 해야한다.
- 레코드 비중이 아주 낮은 컬럼인 경우 두 칼럼 간 순서는 자유롭게 해도 무방하다.

## 아래에 대한 설명
![image](https://github.com/user-attachments/assets/e40f0f28-9868-4fa0-ab98-e25d07cec594)
- 테이블 액세스 횟수만큼 블록 I/O가 발생하였기 때문에 클러스터링 팩터는 매우 나쁜 상태이다.
- 511개의 인덱스 블록을 스캔했는데 이 과정에서 266,476개의 레코드 수에 비하면 큰 수치가 아니다. 비효율성이 크지 않기 때문에, 순서를 조정한다고 해도 I/O가 약간 감소한다고 해도 큰 영향을 미치지는 않을 것이다.
- CPU Time과 Elapsed Time의 차이가 발생한 이유는 27,000여개의 I/O Call 과정에서 발생한 대기 현상 문제일 가능성이 가장 높다.